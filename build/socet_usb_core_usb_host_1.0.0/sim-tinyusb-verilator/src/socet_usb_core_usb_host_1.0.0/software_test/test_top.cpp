#include <verilated.h>
#include "Vusb_host.h" // Generated by Verilator from usb_host.sv
#include <iostream>

// Global pointer to the Verilated model
Vusb_host* top;
vluint64_t main_time = 0;

extern "C" int app_main(void);

// Standard Verilator double-toggle to advance one clock cycle
void tick() {
    top->clk_i = 1;
    top->eval();
    main_time += 5;
    top->clk_i = 0;
    top->eval();
    main_time += 5;
}

// Reset the IP
void reset_ip() {
    top->n_rst_i = 0; // Note: Matched to n_rst_i from usbh_host.sv
    for (int i = 0; i < 10; i++) tick();
    top->n_rst_i = 1;
    tick();
}

// -----------------------------------------------------------------
// CYCLE-ACCURATE AHB REGISTER WRITE
// -----------------------------------------------------------------
extern "C" void usbhw_reg_write(uint32_t addr, uint32_t data) {
    // --- 1. AHB Address Phase ---
    top->hsel_i = 1;
    top->haddr_i = addr;
    top->hwrite_i = 1; // 1 = Write
    top->htrans_i = 2; // 2 = NONSEQ (Single Transfer)
    top->hsize_i = 2;  // 2 = 32-bit word
    
    // Drive clock edge so the slave samples the Address Phase
    tick();

    // --- 2. AHB Data Phase ---
    top->hwdata_i = data;
    
    // Crucial: Transition to IDLE immediately so the IP doesn't think 
    // we are initiating a second back-to-back transfer if HREADY is low.
    top->htrans_i = 0; // 0 = IDLE
    top->hsel_i = 0;

    // Wait for the slave to finish processing the data phase
    do {
        tick(); // Each tick gives the slave a cycle to process and assert hready_o
    } while (!top->hready_o);
}

// -----------------------------------------------------------------
// CYCLE-ACCURATE AHB REGISTER READ
// -----------------------------------------------------------------
extern "C" uint32_t usbhw_reg_read(uint32_t addr) {
    // --- 1. AHB Address Phase ---
    top->hsel_i = 1;
    top->haddr_i = addr;
    top->hwrite_i = 0; // 0 = Read
    top->htrans_i = 2; // 2 = NONSEQ
    top->hsize_i = 2;  // 2 = 32-bit word
    
    // Drive clock edge so the slave samples the Address Phase
    tick();

    // --- 2. AHB Data Phase ---
    // Transition to IDLE so we don't accidentally start another read
    top->htrans_i = 0; // 0 = IDLE
    top->hsel_i = 0;

    // Wait for the slave to provide the data
    do {
        tick();
    } while (!top->hready_o);
    
    // Slave has asserted hready_o, meaning hrdata_o is now valid
    return top->hrdata_o;
}

int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);
    top = new Vusb_host;

    reset_ip();

    // Start the TinyUSB software thread
    app_main();

    delete top;
    return 0;
}